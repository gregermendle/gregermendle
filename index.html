<!DOCTYPE html>
<html class="dark">
  <head>
    <title>Gregory Jordan - Building products in AI, DevX, and Crypto.</title>
    <meta
      name="description"
      content="Gregory Jordan is a seasoned multi-disciplinary engineer building for businesses in AI, DevX, Crypto, and more."
    />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta property="og:url" content="https://gregermendle.com" />
    <meta property="og:type" content="website" />
    <meta
      property="og:title"
      content="Gregory Jordan - Building products in AI, DevX, Crypto, and empowering small businesses and industry giants."
    />
    <meta
      property="og:description"
      content="Gregory Jordan is a seasoned multi-disciplinary engineer empowering businesses in AI, DevX, Crypto, and more."
    />
    <meta property="og:image" content="https://gregermendle.com/social.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="twitter:domain" content="gregermendle.com" />
    <meta property="twitter:url" content="https://gregermendle.com" />
    <meta
      name="twitter:title"
      content="Gregory Jordan - Building products in AI, DevX, Crypto, and empowering small businesses and industry giants."
    />
    <meta
      name="twitter:description"
      content="Gregory Jordan is a seasoned multi-disciplinary engineer empowering businesses in AI, DevX, Crypto, and more."
    />
    <meta name="twitter:image" content="https://gregermendle.com/social.png" />
    <link rel="stylesheet" type="text/css" href="/output.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@200..900&display=swap"
      rel="stylesheet"
    />
    <title>gregermendle</title>
  </head>
  <body>
    <main>
      <header>
        <div class="flex flex-col gap-6">
          <div class="flex flex-col gap-1">
            <h1>Gregory Jordan</h1>
            <p class="font-light text-sm md:hidden">10+ years of building in boston. never stop building.</p>
          </div>
          <hr class="border-white w-16 border-dotted" />
          <div class="flex flex-col gap-6">
            <div class="flex flex-col gap-2">
              <h1>work</h1>
              <hr class="border-white w-16" />
              <div class="cloud">
                <ul>
                  <li>
                    <a target="_blank" href="https://se.ro">se.ro</a>
                  </li>
                  <li>
                    <a target="_blank" href="https://gexx.ai">gexx</a>
                  </li>
                </ul>
              </div>
            </div>
            <div class="flex flex-col gap-2">
              <h1>projects</h1>
              <hr class="border-white w-16" />
              <div class="cloud">
                <ul>
                  <li>
                    <a target="_blank" href="https://cnvrt.run">cnvrt</a>
                  </li>
                  <li>
                    <a target="_blank" href="https://riptar.gregermendle.com">riptar</a>
                  </li>
                  <li>
                    <a target="_blank" href="https://gregermendle.github.io/inframe/">inframe</a>
                  </li>
                  <li>
                    <a target="_blank" href="https://remix-mailer.gregermendle.com">remix-mailer</a>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
        <p class="font-light text-sm self-start hidden md:block">10+ years of building in boston. never stop building.</p>
      </header>
      <footer>
        <nav>
          <ul>
            <li>
              <a target="_blank" href="https://github.com/gregermendle"
                >github</a
              >
            </li>
            <li>
              <a target="_blank" href="https://twitter.com/_studable_"
                >twitter</a
              >
            </li>
            <li class="footer-btn-group flex items-center gap-2 ml-auto">
              <div id="webgl-toggle" class="webgl-btn">
                <button type="button" title="Toggle WebGL background">
                  <svg
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <ellipse cx="12" cy="12" rx="11" ry="5" stroke="currentColor" stroke-width="1.5" fill="none" />
                    <ellipse cx="12" cy="12" rx="7" ry="3" stroke="currentColor" stroke-width="1" fill="none" opacity="0.5" />
                    <circle cx="12" cy="12" r="3.5" fill="currentColor" />
                    <line x1="4" y1="4" x2="20" y2="20" stroke="currentColor" stroke-width="2" class="webgl-off-line" />
                  </svg>
                </button>
              </div>
              <div id="star">
                <button>
                <svg
                  width="16"
                  height="16"
                  viewBox="0 0 482 470"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M241 0L281.935 161.998L434.112 92.998L332.98 226.006L481.807 301.963L314.762 305.824L348.169 469.539L241 341.346L133.831 469.539L167.238 305.824L0.19281 301.963L149.02 226.006L47.8876 92.998L200.065 161.998L241 0Z"
                    fill="currentColor"
                  />
                </svg>
                </button>
              </div>
            </li>
          </ul>
        </nav>
      </footer>
    </main>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById("canvas");
      const gl = canvas.getContext("webgl");

      if (!gl) {
        console.log("WebGL not supported");
        throw new Error("WebGL not supported");
      }

      // Vertex shader program
      const vsSource = `
        attribute vec4 aVertexPosition;
        void main() {
            gl_Position = aVertexPosition;
        }
      `;

      // Reduce load on mobile devices
      let maxSteps = isMobile() ? 84 : 128;
      let schwarzschildRadius = isMobile() ? 0.6 : 0.4;
      let stepSize = isMobile() ? 0.25 : 0.15;
      let warpSize = isMobile() ? 0.05 : 0.25;

      // Fragment shader program (your provided shader)
      const fsSource = `
        precision highp float;
        uniform vec2 resolution;
        uniform float time;
        uniform vec2 mouse;
        uniform float invert;
        uniform float progress;
        uniform float stepSize;

        #define MAX_STEPS ${maxSteps}
        #define SCHWARZSCHILD_RADIUS ${schwarzschildRadius.toFixed(2)}
        #define PI 3.14159265359
        #define WARP_SIZE ${warpSize.toFixed(2)}

        vec4 diskColor(float dist)
        {
            float innerTemp = smoothstep(2.0, 4.0, dist);
            float outerTemp = smoothstep(4.0, 8.0, dist);

            float gray = mix(1.0, mix(0.4, 0.1, outerTemp), innerTemp);
            gray = mix(gray, 1.0 - gray, invert);
            float intensity = exp(-dist * 0.25);
            return vec4(vec3(gray * intensity), 1.0);
        }

        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }

        vec4 rayMarch(vec3 ro, vec3 rd, vec2 uv, float radius, vec2 aspect) {
          float jitter = hash(uv) * stepSize;
          vec3 p = ro + rd * jitter;
          float r = length(p);
          vec4 col = vec4(0.);
          float totalDist = jitter;
          const float diskThickness = 0.12;
          const float diskColorFalloff = 0.05;
          const float rotationSpeed = 0.3;
          const float spiralFreq = 8.0;
          const float spiralAmp = 0.08;
          float rdDotP = dot(rd, normalize(p));
          float influenceRadius = radius * 50.0;
          if (r > influenceRadius && rdDotP > 0.0) {
              return col;
          }

          float baseStepSize = stepSize;
          float adaptiveStepSize;
          bool inInfluenceZone = false;
          bool nearDisk = false;
          
          for (int i = 0; i < MAX_STEPS; i++) {
              r = length(p);
              adaptiveStepSize = baseStepSize * max(1.0, r * 0.1);
              inInfluenceZone = r < influenceRadius;
              
              if (inInfluenceZone) {
                  float force = radius / (r * r);
                  vec3 gravity = normalize(p) * -force;
                  rd += gravity * adaptiveStepSize;
                  rd = normalize(rd);
              } else {
                return col;
              }

              p += rd * adaptiveStepSize;
              totalDist += adaptiveStepSize;
              nearDisk = abs(p.y) < diskThickness;
              
              if (nearDisk) {
                  float diskRadius = length(vec2(p.x, p.z));
                  
                  if (diskRadius > radius) {
                      vec4 diskCol = diskColor(diskRadius) * exp(-totalDist * 0.07);
                      
                      float angle = atan(p.z, p.x) + time * rotationSpeed;
                      diskCol *= 1.0 + spiralAmp * sin(angle * spiralFreq);

                      angle = atan(rd.x, rd.y) + time * rotationSpeed;
                      diskCol *= .75 + spiralAmp * sin(angle * spiralFreq);

                      col += diskCol * exp(-totalDist * diskColorFalloff);
                  }
              }
              
              if (r < radius || totalDist > 100.0 || length(col) > 10.0) {
                return col;
              }
          }

          return col;
        }

        void main()
        {
          vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / min(resolution.x, resolution.y);
          vec2 aspect = resolution.xy / min(resolution.x, resolution.y);
          vec2 muv = (mouse.xy - 0.5) * aspect;

          float warp = 1.0 - smoothstep(0.0, WARP_SIZE, length(uv - muv));
          vec2 outward = normalize(muv - uv + 0.001) * warp * 2.0;
          vec3 ro = vec3(-1.0, 2.0, -10.0) + vec3(muv * 2., 0.) + vec3(outward, 0.);

          vec3 rd = normalize(vec3(uv, 1.0)) - vec3(0., 0.2, 0.);

          vec4 col = rayMarch(
            ro, 
            rd, 
            uv * aspect * 5., 
            SCHWARZSCHILD_RADIUS * progress, 
            aspect);

          gl_FragColor = col * progress;
        }
      `;

      function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert(
            "Unable to initialize the shader program: " +
              gl.getProgramInfoLog(shaderProgram)
          );
          return null;
        }

        return shaderProgram;
      }

      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert(
            "An error occurred compiling the shaders: " +
              gl.getShaderInfoLog(shader)
          );
          gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      function isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        );
      }

      function initBuffers(gl) {
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        const positions = [-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0];

        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(positions),
          gl.STATIC_DRAW
        );

        return {
          position: positionBuffer,
        };
      }

      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      const programInfo = {
        program: shaderProgram,
        attribLocations: {
          vertexPosition: gl.getAttribLocation(
            shaderProgram,
            "aVertexPosition"
          ),
        },
        uniformLocations: {
          resolution: gl.getUniformLocation(shaderProgram, "resolution"),
          time: gl.getUniformLocation(shaderProgram, "time"),
          mouse: gl.getUniformLocation(shaderProgram, "mouse"),
          invert: gl.getUniformLocation(shaderProgram, "invert"),
          progress: gl.getUniformLocation(shaderProgram, "progress"),
          stepSize: gl.getUniformLocation(shaderProgram, "stepSize"),
        },
      };

      const blitVsSource = `
        attribute vec4 aVertexPosition;
        varying vec2 vTexCoord;
        void main() {
          gl_Position = aVertexPosition;
          vTexCoord = aVertexPosition.xy * 0.5 + 0.5;
        }
      `;

      const blitFsSource = `
        precision highp float;
        uniform sampler2D uTex;
        varying vec2 vTexCoord;
        void main() {
          gl_FragColor = texture2D(uTex, vTexCoord);
        }
      `;

      const blitProgram = initShaderProgram(gl, blitVsSource, blitFsSource);

      const DITHER_THRESHOLD = 128;
      const LUM_SCALE = 1 / 3;
      const RENDER_SCALE = 0.3;

      let ditherLum = null;
      let ditherWork = null;
      let ditherOut = null;
      let ditherOutput = null;

      function applyDitheringAndAberration(pixels, width, height, aberrationOff) {
        const n = width * height;
        const w = width;
        const w4 = w * 4;

        if (!ditherLum || ditherLum.length < n) {
          ditherLum = new Float32Array(n);
          ditherWork = new Float32Array(n);
          ditherOut = new Uint8Array(n);
          ditherOutput = new Uint8Array(n * 4);
        }

        const out = ditherOutput;
        const off = Math.max(0, aberrationOff | 0);
        const clampX = (x) => (x < 0 ? 0 : x >= w ? w - 1 : x);

        for (let i = 0; i < n; i++) {
          const i4 = i * 4;
          ditherLum[i] = (pixels[i4] + pixels[i4 + 1] + pixels[i4 + 2]) * LUM_SCALE;
        }

        ditherWork.set(ditherLum);

        const e7 = 7 / 16, e3 = 3 / 16, e5 = 5 / 16, e1 = 1 / 16;
        for (let y = 0; y < height; y++) {
          const rowBase = y * w;
          for (let x = 0; x < w; x++) {
            const i = rowBase + x;
            const oldVal = ditherWork[i];
            if (oldVal === 0) {
              ditherOut[i] = 0;
            } else {
              const newVal = oldVal < DITHER_THRESHOLD ? 0 : 255;
              const err = oldVal - newVal;
              ditherOut[i] = newVal;
              if (x + 1 < w) ditherWork[i + 1] += err * e7;
              if (y + 1 < height) {
                if (x > 0) ditherWork[i + w - 1] += err * e3;
                ditherWork[i + w] += err * e5;
                if (x + 1 < w) ditherWork[i + w + 1] += err * e1;
              }
            }
          }
        }

        for (let i = 0; i < n; i++) {
          const y = (i / w) | 0;
          const x = i % w;
          const d = ditherOut[i];
          const oi = i * 4;
          out[oi + 3] = 255;
          if (d === 0) {
            out[oi] = out[oi + 1] = out[oi + 2] = 0;
          } else if (off > 0) {
            const row = y * w4;
            out[oi] = pixels[row + clampX(x + off) * 4];
            out[oi + 1] = pixels[row + x * 4 + 1];
            out[oi + 2] = pixels[row + clampX(x - off) * 4 + 2];
          } else {
            const i4 = i * 4;
            out[oi] = pixels[i4];
            out[oi + 1] = pixels[i4 + 1];
            out[oi + 2] = pixels[i4 + 2];
          }
        }

        return out;
      }

      let framebuffer = null;
      let sceneTexture = null;
      let displayTexture = null;
      let pixelBuffer = null;

      function initFramebuffer(gl, width, height) {
        if (framebuffer) {
          gl.deleteFramebuffer(framebuffer);
          gl.deleteTexture(sceneTexture);
          gl.deleteTexture(displayTexture);
        }
        sceneTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, sceneTexture);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          width,
          height,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          null
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        displayTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, displayTexture);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          width,
          height,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          null
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          sceneTexture,
          0
        );

        pixelBuffer = new Uint8Array(width * height * 4);
      }

      const blitProgramInfo = {
        program: blitProgram,
        attribLocations: {
          vertexPosition: gl.getAttribLocation(blitProgram, "aVertexPosition"),
        },
        uniformLocations: {
          uTex: gl.getUniformLocation(blitProgram, "uTex"),
        },
      };

      const buffers = initBuffers(gl);

      function clamp(n, min, max) {
        return Math.min(Math.max(n, min), max);
      }

      function toggleInvert() {
        const html = document.querySelector("html");
        html.classList.toggle("inverted");
        const inverted = html.classList.contains("inverted");
        localStorage.setItem("invert", inverted ? "1" : "0");
      }

      if (localStorage.getItem("invert") === "1") {
        document.querySelector("html").classList.add("inverted");
      }

      document.getElementById("star").addEventListener("click", toggleInvert);

      const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      let webglEnabled = !prefersReducedMotion && localStorage.getItem("webgl") === "1";

      const webglToggleEl = document.getElementById("webgl-toggle");

      function toggleWebGL() {
        if (prefersReducedMotion) return;
        webglEnabled = !webglEnabled;
        localStorage.setItem("webgl", webglEnabled ? "1" : "0");
        canvas.style.display = webglEnabled ? "" : "none";
        webglToggleEl.classList.toggle("webgl-off", !webglEnabled);
        if (webglEnabled) requestAnimationFrame(render);
      }

      if (!webglEnabled) {
        canvas.style.display = "none";
        webglToggleEl.classList.add("webgl-off");
      }

      document.getElementById("webgl-toggle").addEventListener("click", toggleWebGL);

      let mouseX = 0;
      let mouseY = 0;

      let nextMouseX = 0;
      let nextMouseY = 0;

      document.addEventListener("pointermove", (e) => {
        nextMouseX = e.clientX / window.innerWidth;
        nextMouseY = 1.0 - e.clientY / window.innerHeight;
      });

      function easeOutBack(x) {
        const c1 = 1.70158;
        const c3 = c1 + 1;

        return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
      }

      let prevNow = 0;
      let progress = 0;

      function render(now) {
        const dt = now - prevNow;
        prevNow = now;
        const timeScale = Math.abs(1 - (dt - 1));
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;

        progress = Math.min(1, progress + 0.0025);

        let dx = nextMouseX - mouseX;
        let dy = nextMouseY - mouseY;
        mouseX = mouseX + dx * 0.01 * timeScale;
        mouseY = mouseY + dy * 0.01 * timeScale;

        const renderWidth = Math.max(1, (displayWidth * RENDER_SCALE) | 0);
        const renderHeight = Math.max(1, (displayHeight * RENDER_SCALE) | 0);

        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
          canvas.width = displayWidth;
          canvas.height = displayHeight;
          gl.viewport(0, 0, canvas.width, canvas.height);
          initFramebuffer(gl, renderWidth, renderHeight);
        }

        if (!framebuffer && canvas.width > 0 && canvas.height > 0) {
          initFramebuffer(gl, renderWidth, renderHeight);
        }

        if (!framebuffer || canvas.width === 0 || canvas.height === 0) {
          requestAnimationFrame(render);
          return;
        }

        if (!webglEnabled) {
          return;
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.viewport(0, 0, renderWidth, renderHeight);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(programInfo.program);

        gl.uniform2f(
          programInfo.uniformLocations.resolution,
          renderWidth,
          renderHeight
        );
        gl.uniform1f(programInfo.uniformLocations.time, now * 0.001);
        gl.uniform1f(
          programInfo.uniformLocations.progress,
          easeOutBack(progress)
        );
        gl.uniform2f(programInfo.uniformLocations.mouse, mouseX, mouseY);
        gl.uniform1f(programInfo.uniformLocations.invert, 0);

        gl.uniform1f(programInfo.uniformLocations.stepSize, stepSize);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.vertexAttribPointer(
          programInfo.attribLocations.vertexPosition,
          2,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        gl.readPixels(0, 0, renderWidth, renderHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixelBuffer);

        const aberrationOffset = 4;
        const dithered = applyDitheringAndAberration(
          pixelBuffer,
          renderWidth,
          renderHeight,
          aberrationOffset
        );

        gl.bindTexture(gl.TEXTURE_2D, displayTexture);
        gl.texSubImage2D(
          gl.TEXTURE_2D,
          0,
          0,
          0,
          renderWidth,
          renderHeight,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          dithered
        );

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, displayWidth, displayHeight);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(blitProgramInfo.program);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, displayTexture);
        gl.uniform1i(blitProgramInfo.uniformLocations.uTex, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.vertexAttribPointer(
          blitProgramInfo.attribLocations.vertexPosition,
          2,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(blitProgramInfo.attribLocations.vertexPosition);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    </script>
    <script>
      !(function (t, e) {
        var o, n, p, r;
        e.__SV ||
          ((window.posthog = e),
          (e._i = []),
          (e.init = function (i, s, a) {
            function g(t, e) {
              var o = e.split(".");
              2 == o.length && ((t = t[o[0]]), (e = o[1])),
                (t[e] = function () {
                  t.push([e].concat(Array.prototype.slice.call(arguments, 0)));
                });
            }
            ((p = t.createElement("script")).type = "text/javascript"),
              (p.crossOrigin = "anonymous"),
              (p.async = !0),
              (p.src =
                s.api_host.replace(".i.posthog.com", "-assets.i.posthog.com") +
                "/static/array.js"),
              (r = t.getElementsByTagName("script")[0]).parentNode.insertBefore(
                p,
                r
              );
            var u = e;
            for (
              void 0 !== a ? (u = e[a] = []) : (a = "posthog"),
                u.people = u.people || [],
                u.toString = function (t) {
                  var e = "posthog";
                  return (
                    "posthog" !== a && (e += "." + a), t || (e += " (stub)"), e
                  );
                },
                u.people.toString = function () {
                  return u.toString(1) + ".people (stub)";
                },
                o =
                  "init capture register register_once register_for_session unregister unregister_for_session getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSessionId getSurveys getActiveMatchingSurveys renderSurvey canRenderSurvey getNextSurveyStep identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty createPersonProfile opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing clear_opt_in_out_capturing debug".split(
                    " "
                  ),
                n = 0;
              n < o.length;
              n++
            )
              g(u, o[n]);
            e._i.push([i, s, a]);
          }),
          (e.__SV = 1));
      })(document, window.posthog || []);
      posthog.init("phc_xT6rtTPbZa8WF5BFsVQsgy5yhs56cRxZlTJmhmstg5d", {
        api_host: "https://us.i.posthog.com",
        person_profiles: "always", // or 'always' to create profiles for anonymous users as well
      });
    </script>
  </body>
</html>
