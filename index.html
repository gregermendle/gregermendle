<!DOCTYPE html>
<html>
  <head>
    <!-- HTML Meta Tags -->
    <title>
      Gregory Jordan - Building products in AI, DevX, Crypto, and empowering
      small businesses.
    </title>
    <meta
      name="description"
      content="Gregory Jordan is a seasoned multi-disciplinary engineer empowering businesses in AI, DevX, Crypto, and more."
    />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Facebook Meta Tags -->
    <meta property="og:url" content="https://gregermendle.com/social.png" />
    <meta property="og:type" content="website" />
    <meta
      property="og:title"
      content="Gregory Jordan - Building products in AI, DevX, Crypto, and empowering small businesses and industry giants."
    />
    <meta
      property="og:description"
      content="Gregory Jordan is a seasoned multi-disciplinary engineer empowering businesses in AI, DevX, Crypto, and more."
    />
    <meta property="og:image" content="" />

    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="twitter:domain" content="gregermendle.com" />
    <meta
      property="twitter:url"
      content="https://gregermendle.com/social.png"
    />
    <meta
      name="twitter:title"
      content="Gregory Jordan - Building products in AI, DevX, Crypto, and empowering small businesses and industry giants."
    />
    <meta
      name="twitter:description"
      content="Gregory Jordan is a seasoned multi-disciplinary engineer empowering businesses in AI, DevX, Crypto, and more."
    />
    <meta name="twitter:image" content="" />

    <!-- Meta Tags Generated via https://www.opengraph.xyz -->
    <link rel="stylesheet" type="text/css" href="/output.css" />
    <title>gregermendle</title>
  </head>
  <body>
    <main>
      <header>
        <h1>Gregory Jordan</h1>
      </header>
      <footer>
        <nav>
          <ul>
            <li>
              <a target="_blank" href="https://github.com/gregermendle"
                >github</a
              >
            </li>
            <li>
              <a target="_blank" href="https://twitter.com/_studable_"
                >twitter</a
              >
            </li>
            <li>
              <a
                target="_blank"
                href="https://discordapp.com/users/289963161044385802"
                >discord</a
              >
            </li>
            <li id="star">
              <button>
                <svg
                  width="16"
                  height="16"
                  viewBox="0 0 482 470"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M241 0L281.935 161.998L434.112 92.998L332.98 226.006L481.807 301.963L314.762 305.824L348.169 469.539L241 341.346L133.831 469.539L167.238 305.824L0.19281 301.963L149.02 226.006L47.8876 92.998L200.065 161.998L241 0Z"
                    fill="currentColor"
                  />
                </svg>
              </button>
            </li>
          </ul>
        </nav>
      </footer>
    </main>
    <canvas
      id="canvas"
      class="fixed inset-0 w-screen h-screen z-20 mix-blend-difference pointer-events-none"
    ></canvas>
    <script>
      const canvas = document.getElementById("canvas");
      const gl = canvas.getContext("webgl");

      if (!gl) {
        console.log("WebGL not supported");
        throw new Error("WebGL not supported");
      }

      // Vertex shader program
      const vsSource = `
            attribute vec4 aVertexPosition;
            void main() {
                gl_Position = aVertexPosition;
            }
        `;

      // Fragment shader program (your provided shader)
      const fsSource = `
            precision highp float;

            uniform vec2 resolution;
            uniform vec3 color;
            uniform float time;
            uniform vec2 mouse;

            const float WAVELENGTH = 0.1;
            const float SLIT_SEPARATION = 0.15;
            const float DISTANCE = 0.5;

            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            vec3 invert(vec3 color) {
                return vec3(1.0) - color;
            }

            void main() {
                vec2 uv = gl_FragCoord.xy/resolution.xy;
                float aspect = resolution.x/resolution.y;

                vec2 centered;
                if(aspect > 1.0) {
                    centered = vec2((uv.x - 0.5) * aspect, uv.y - 0.5);
                } else {
                    centered = vec2(uv.x - 0.5, (uv.y - 0.5) / aspect);
                }

                float radius = length(centered * (mouse + vec2(0.4, 0.9)));
                float circle = smoothstep(0.4, 0.0, radius);
                float x = centered.x * 3.0;
                float pathDiff = SLIT_SEPARATION * x / DISTANCE;
                float pattern = 0.5 + 0.5 * tan(2.0 * 3.14159 * pathDiff / WAVELENGTH) + cos(pathDiff / WAVELENGTH);
                float envelope = exp(-radius * radius * 4.0);
                pattern *= envelope;
                pattern = pow(pattern, 0.4);
                pattern = smoothstep(0.2, 1.0, pattern);
                vec3 color = mix(color, invert(color), pattern * circle * 0.9);
                float r = random(uv + time / 900.0);
                color *= 0.95 + r * 0.3;

                gl_FragColor = vec4(color, 1.0);
            }
        `;

      // Initialize a shader program
      function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert(
            "Unable to initialize the shader program: " +
              gl.getProgramInfoLog(shaderProgram)
          );
          return null;
        }

        return shaderProgram;
      }

      // Create a shader of the given type, upload source and compile it
      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert(
            "An error occurred compiling the shaders: " +
              gl.getShaderInfoLog(shader)
          );
          gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      // Initialize buffers
      function initBuffers(gl) {
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        const positions = [-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0];

        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(positions),
          gl.STATIC_DRAW
        );

        return {
          position: positionBuffer,
        };
      }

      // Initialize everything
      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      const programInfo = {
        program: shaderProgram,
        attribLocations: {
          vertexPosition: gl.getAttribLocation(
            shaderProgram,
            "aVertexPosition"
          ),
        },
        uniformLocations: {
          resolution: gl.getUniformLocation(shaderProgram, "resolution"),
          time: gl.getUniformLocation(shaderProgram, "time"),
          mouse: gl.getUniformLocation(shaderProgram, "mouse"),
          color: gl.getUniformLocation(shaderProgram, "color"),
        },
      };

      const buffers = initBuffers(gl);

      function clamp(n, min, max) {
        return Math.min(Math.max(n, min), max);
      }

      // Scrolling
      let r = 1.0;
      let g = 1.0;
      let b = 1.0;

      let nextR = 1.0;
      let nextG = 1.0;
      let nextB = 1.0;

      document.getElementById("star").addEventListener("click", (e) => {
        nextR = clamp(Math.random(), 0.01, 1.0);
        nextG = clamp(Math.random(), 0.01, 1.0);
        nextB = clamp(Math.random(), 0.01, 1.0);
      });

      let mouseX = 1.0;
      let mouseY = 1.0;

      let nextMouseX = 1.0;
      let nextMouseY = 1.0;
      document.addEventListener("mousemove", (e) => {
        nextMouseX = e.clientX / window.innerWidth;
        nextMouseY = 1.0 - e.clientY / window.innerHeight;
      });

      let prevNow = 0;
      function render(now) {
        const dt = now - prevNow;
        prevNow = now;
        const timeScale = Math.abs(1 - (dt - 1));
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;

        let dr = nextR - r;
        let dg = nextG - g;
        let db = nextB - b;

        r = r + dr * 0.005 * timeScale;
        g = g + dg * 0.01 * timeScale;
        b = b + db * 0.01 * timeScale;

        let dx = nextMouseX - mouseX;
        let dy = nextMouseY - mouseY;
        mouseX = mouseX + dx * 0.01 * timeScale;
        mouseY = mouseY + dy * 0.01 * timeScale;

        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
          canvas.width = displayWidth;
          canvas.height = displayHeight;
          gl.viewport(0, 0, canvas.width, canvas.height);
        }

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(programInfo.program);

        gl.uniform2f(
          programInfo.uniformLocations.resolution,
          canvas.width,
          canvas.height
        );
        gl.uniform1f(
          programInfo.uniformLocations.time,
          now * 0.001 * timeScale
        );
        gl.uniform2f(programInfo.uniformLocations.mouse, mouseX, mouseY);
        gl.uniform3f(programInfo.uniformLocations.color, r, g, b);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.vertexAttribPointer(
          programInfo.attribLocations.vertexPosition,
          2,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    </script>
    <script>
      !(function (t, e) {
        var o, n, p, r;
        e.__SV ||
          ((window.posthog = e),
          (e._i = []),
          (e.init = function (i, s, a) {
            function g(t, e) {
              var o = e.split(".");
              2 == o.length && ((t = t[o[0]]), (e = o[1])),
                (t[e] = function () {
                  t.push([e].concat(Array.prototype.slice.call(arguments, 0)));
                });
            }
            ((p = t.createElement("script")).type = "text/javascript"),
              (p.crossOrigin = "anonymous"),
              (p.async = !0),
              (p.src =
                s.api_host.replace(".i.posthog.com", "-assets.i.posthog.com") +
                "/static/array.js"),
              (r = t.getElementsByTagName("script")[0]).parentNode.insertBefore(
                p,
                r
              );
            var u = e;
            for (
              void 0 !== a ? (u = e[a] = []) : (a = "posthog"),
                u.people = u.people || [],
                u.toString = function (t) {
                  var e = "posthog";
                  return (
                    "posthog" !== a && (e += "." + a), t || (e += " (stub)"), e
                  );
                },
                u.people.toString = function () {
                  return u.toString(1) + ".people (stub)";
                },
                o =
                  "init capture register register_once register_for_session unregister unregister_for_session getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSessionId getSurveys getActiveMatchingSurveys renderSurvey canRenderSurvey getNextSurveyStep identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty createPersonProfile opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing clear_opt_in_out_capturing debug".split(
                    " "
                  ),
                n = 0;
              n < o.length;
              n++
            )
              g(u, o[n]);
            e._i.push([i, s, a]);
          }),
          (e.__SV = 1));
      })(document, window.posthog || []);
      posthog.init("phc_xT6rtTPbZa8WF5BFsVQsgy5yhs56cRxZlTJmhmstg5d", {
        api_host: "https://us.i.posthog.com",
        person_profiles: "identified_only", // or 'always' to create profiles for anonymous users as well
      });
    </script>
  </body>
</html>
